\section{Introduction}
\label{sec:introduction}
Networks created by reinforced random walks are found in many complex systems, everything from biological systems such as construction of blood vessels or neural networks to trail-laying ants can at some level be described by a reinforced random walk. These biological systems can be seen as a massive cluster of tiny computational units, e.g.\@ ants, generating the network in parallel, with every tiny component only knowing its local environment. Modelling complex systems with reinforced random walks is often done by simulating particles traveling from node to node in a specified graph, constructing networks. The paths taken by the particles depend on local environmental parameters in each node. The parameters for a node can for example be the particle density within the node or the flow of particles to another node. The probability for a particle to move to another node then depend on these parameters. Ants for example, as presented in \cite{Schweitzer1997153}, move around in their search for food or building material drop pheromone in certain patterns. If an ant has found food it drops an amount of pheromone which other ants can then register. Ants want to move along paths where the pheromone concentration is high, i.e.\@ where other ants are moving. This causes the ants to create so called current-reinforced patterns through their transport network.

Previous studies have shown how biological systems can be modelled by current-reinforced random walks. In current-reinforced random walks, the probability for a particle to move to another node depends on the flow of particles to that node, i.e.\@ the current of particles. The basic idea of a current-reinforced random walk is to find the shortest path between a source and a sink for a given graph. This optimises the path length for each individual path from the sources to the sinks. The algorithm for network creation by current-reinforced random walks used in \cite{Sumpter} converges to the shortest path through the graph \cite{Ito}. When utilising non linear current-reinforced random walks a combination of path length and path maintenance is minimised. For example, ants may want to construct one big road rather than many small ones to easier keep needles and dirt off the road while not making each individual path that much longer. The actual function that is minimised in non linear cases is not yet known, a suggestion for this function is given in \cite{Sumpter}.

Another example of where to find networks that can be modelled by current-reinforced random walks is in certain types of electrical systems. As presented in \cite{Sumpter}, the movement of the electrons in special types of current dependent conductors can be modelled by current-reinforced random walks. In these systems the conductivity in the conductors is proportional to the amount of electrons flowing through it, i.e.\@ the current. This property enables the analogy to ant trail networks where pheromone concentration corresponds to the conductivity in the electrical network. What is unanimous for all these different networks is that the particles flowing within the network have no global information of the network itself, i.e.\@ they can only know and affect their local environment. 

When simulating these systems It may seem natural to implement the algorithms within a parallel setting due to the parallel nature of the systems themselves. However, previous simulations of current-reinforced random walks have been implemented serially in low performance environments \cite{Sumpter, Ma2012rib}. This is mainly because high performance parallel programming is not that simple as it may seem at first glance. Since all particles affect and react to their local environment synchronisation is needed when moving particles around in the network, otherwise the computation would be corrupted. This project aims to be the first high performance parallel implementation of the current-reinforced random walk network creation presented in \cite{Sumpter}, utilising high performance languages such as \texttt{C++} along with graph partitioning schemes such as METIS \cite{Lasalle} for better performance. The purpose is to decrease computation time and increase the problem size. Relevant measures for this is speedup and sizeup as a function of number of utilised parallel cores.