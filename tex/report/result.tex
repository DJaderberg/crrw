\section{Result}
\label{sec:result}

\subsection{Homogeneous grid}
A homogeneous grid containing $1024$ nodes where each node has been perturbed a small amount was used to execute the algorithm with several different choices of parameters, with a focus on the maintenance parameter, $\mu$. This is shown in Figure \ref{fig:homogeneous}, which shows that when $\mu = 1$, i.e. the linear case, the solution that is found is the shortest path between each source and sink. When $\mu > 1$, the path chosen may not be the shortest path and there also exists a preference to share paths.

\begin{figure}
\centering
\begin{subfigure}[b]{0.48\textwidth}
\includegraphics[width=\textwidth]{img/Lin.png}
\caption{The simulated solution when $\mu=1$. This is the shortest possible path from the source to each sink.
\\
\\}
\end{subfigure}
~
\begin{subfigure}[b]{0.48\textwidth}
\includegraphics[width=\textwidth]{img/NonLin.png}
\caption{The simulated solution when $\mu=1.5$. This is not the shortest possible path, but rather shows a preference to take the same path as other particles, if it is not too much longer.}
\end{subfigure}
\caption{Figure shows the solutions found by the simulation on a nearly homogeneous grid. The pink lines show the flow along each edge, with the thickness of the line showing the amount of flow. The shortest path from each source to each sinks has been marked with a thin white line. The parameters used are $q = 10^{-4},\lambda = 10^{-3},$ and $D_{min}=5 \cdot 10^{-2}$. Each source (red) produces 1000 particles each time unit and all sinks (blue) can together remove as many particles as are produced each time unit (evenly divided between the sinks).}
\label{fig:homogeneous}
\end{figure}

\subsection{City}

Another grid was created using road data from the city of Uppsala, Sweden.

\subsection{Parallelism}
The measures used to benchmark the performance of the parallel OpenMP implementation was speedup and sizeup. Figure \ref{fig:speed_size} shows the result from the speedup and sizeup measurements. All benchmarking were done on the Uppsala University server \textit{vitsippa.it.uu.se} with specifications: 

\begin{itemize}
\item CPU: AMD Opteron (Bulldozer) 6282SE, 2.6 GHz, 16-core, dual socket
\item Memory: 128 GB
\item OS: Scientifix Linux 6.5
\end{itemize}

\noindent All \texttt{C++} code was compiled with \texttt{gcc 4.8.2} with the \texttt{-fopenmp}, \texttt{-O3} and  \texttt{-static-libstdc++} flags. 

\begin{figure}
\centering
\begin{subfigure}[b]{1\textwidth}
\includegraphics[width=\textwidth, height=0.5\textwidth]{img/speedup.png}
\caption{The speedup of the parallel implementation. A uniformly randomized grid containing $10000$ nodes was used for measuring the speedup. The simulation was run for $1000$ iterations with a time step of $0.1$.}
\end{subfigure}

\begin{subfigure}[b]{1\textwidth}
\includegraphics[width=\textwidth, height=0.5\textwidth]{img/sizeup.png}
\caption{The sizeup of the parallel implementation. The reference size, i.e. the size of the problem when sizeup is one was a uniformly randomized grid containing $5000$ nodes. The computation time used for measuring the sizeup was $60~s$ with an allowed variation of $\pm 3~s$. }
\end{subfigure}
\caption{Figure shows the different measurements of the parallel implementation of the algorithm presented in Algorithm \ref{alg:outline}. All benchmarking was run three times per data point and the best performance among those data points was extracted and used in these results.}
\label{fig:speed_size}
\end{figure}

